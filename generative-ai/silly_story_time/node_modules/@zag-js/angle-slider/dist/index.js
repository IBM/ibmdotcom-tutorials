'use strict';

var anatomy$1 = require('@zag-js/anatomy');
var domQuery = require('@zag-js/dom-query');
var rectUtils = require('@zag-js/rect-utils');
var utils = require('@zag-js/utils');
var core = require('@zag-js/core');
var types = require('@zag-js/types');

// src/angle-slider.anatomy.ts
var anatomy = anatomy$1.createAnatomy("angle-slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "control",
  "track",
  "markerGroup",
  "marker"
);
var parts = anatomy.build();

// src/angle-slider.dom.ts
var getRootId = (ctx) => ctx.ids?.root ?? `angle-slider:${ctx.id}`;
var getThumbId = (ctx) => ctx.ids?.thumb ?? `angle-slider:${ctx.id}:thumb`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `angle-slider:${ctx.id}:input`;
var getControlId = (ctx) => ctx.ids?.control ?? `angle-slider:${ctx.id}:control`;
var getValueTextId = (ctx) => ctx.ids?.valueText ?? `angle-slider:${ctx.id}:value-text`;
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
var getControlEl = (ctx) => ctx.getById(getControlId(ctx));
var getThumbEl = (ctx) => ctx.getById(getThumbId(ctx));

// src/angle-slider.connect.ts
function connect(service, normalize) {
  const { state, send, context, prop, computed, scope } = service;
  const dragging = state.matches("dragging");
  const value = context.get("value");
  const valueAsDegree = computed("valueAsDegree");
  const disabled = prop("disabled");
  const invalid = prop("invalid");
  const readOnly = prop("readOnly");
  const interactive = computed("interactive");
  return {
    value,
    valueAsDegree,
    dragging,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        id: getRootId(scope),
        "data-disabled": domQuery.dataAttr(disabled),
        "data-invalid": domQuery.dataAttr(invalid),
        "data-readonly": domQuery.dataAttr(readOnly),
        style: {
          "--value": value,
          "--angle": valueAsDegree
        }
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts.label.attrs,
        htmlFor: getHiddenInputId(scope),
        "data-disabled": domQuery.dataAttr(disabled),
        "data-invalid": domQuery.dataAttr(invalid),
        "data-readonly": domQuery.dataAttr(readOnly),
        onClick(event) {
          if (!interactive) return;
          event.preventDefault();
          getThumbEl(scope)?.focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize.element({
        type: "hidden",
        value,
        name: prop("name"),
        id: getHiddenInputId(scope)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        role: "presentation",
        id: getControlId(scope),
        "data-disabled": domQuery.dataAttr(disabled),
        "data-invalid": domQuery.dataAttr(invalid),
        "data-readonly": domQuery.dataAttr(readOnly),
        onPointerDown(event) {
          if (!interactive) return;
          const point = domQuery.getEventPoint(event);
          send({ type: "CONTROL.POINTER_DOWN", point });
        }
      });
    },
    getThumbProps() {
      return normalize.element({
        ...parts.thumb.attrs,
        id: getThumbId(scope),
        role: "slider",
        "aria-valuemax": 360,
        "aria-valuemin": 0,
        "aria-valuenow": value,
        tabIndex: readOnly || interactive ? 0 : void 0,
        "data-disabled": domQuery.dataAttr(disabled),
        "data-invalid": domQuery.dataAttr(invalid),
        "data-readonly": domQuery.dataAttr(readOnly),
        onFocus() {
          send({ type: "THUMB.FOCUS" });
        },
        onBlur() {
          send({ type: "THUMB.BLUR" });
        },
        onKeyDown(event) {
          if (!interactive) return;
          const step = domQuery.getEventStep(event) * prop("step");
          switch (event.key) {
            case "ArrowLeft":
            case "ArrowUp":
              event.preventDefault();
              send({ type: "THUMB.ARROW_DEC", step });
              break;
            case "ArrowRight":
            case "ArrowDown":
              event.preventDefault();
              send({ type: "THUMB.ARROW_INC", step });
              break;
            case "Home":
              event.preventDefault();
              send({ type: "THUMB.HOME" });
              break;
            case "End":
              event.preventDefault();
              send({ type: "THUMB.END" });
              break;
          }
        },
        style: {
          rotate: `var(--angle)`
        }
      });
    },
    getValueTextProps() {
      return normalize.element({
        ...parts.valueText.attrs,
        id: getValueTextId(scope)
      });
    },
    getMarkerGroupProps() {
      return normalize.element({
        ...parts.markerGroup.attrs
      });
    },
    getMarkerProps(props2) {
      let markerState;
      if (props2.value < value) {
        markerState = "under-value";
      } else if (props2.value > value) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize.element({
        ...parts.marker.attrs,
        "data-value": props2.value,
        "data-state": markerState,
        "data-disabled": domQuery.dataAttr(disabled),
        style: {
          "--marker-value": props2.value,
          rotate: `calc(var(--marker-value) * 1deg)`
        }
      });
    }
  };
}
var MIN_VALUE = 0;
var MAX_VALUE = 359;
var machine = core.createMachine({
  props({ props: props2 }) {
    return {
      step: 1,
      defaultValue: 0,
      ...props2
    };
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value, valueAsDegree: `${value}deg` });
        }
      }))
    };
  },
  computed: {
    interactive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
    valueAsDegree: ({ context }) => `${context.get("value")}deg`
  },
  watch({ track, context, action }) {
    track([() => context.get("value")], () => {
      action(["syncInputElement"]);
    });
  },
  initialState() {
    return "idle";
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    }
  },
  states: {
    idle: {
      on: {
        "CONTROL.POINTER_DOWN": {
          target: "dragging",
          actions: ["setPointerValue", "focusThumb"]
        },
        "THUMB.FOCUS": {
          target: "focused"
        }
      }
    },
    focused: {
      on: {
        "CONTROL.POINTER_DOWN": {
          target: "dragging",
          actions: ["setPointerValue", "focusThumb"]
        },
        "THUMB.ARROW_DEC": {
          actions: ["decrementValue", "invokeOnChangeEnd"]
        },
        "THUMB.ARROW_INC": {
          actions: ["incrementValue", "invokeOnChangeEnd"]
        },
        "THUMB.HOME": {
          actions: ["setValueToMin", "invokeOnChangeEnd"]
        },
        "THUMB.END": {
          actions: ["setValueToMax", "invokeOnChangeEnd"]
        },
        "THUMB.BLUR": {
          target: "idle"
        }
      }
    },
    dragging: {
      entry: ["focusThumb"],
      effects: ["trackPointerMove"],
      on: {
        "DOC.POINTER_UP": {
          target: "focused",
          actions: ["invokeOnChangeEnd"]
        },
        "DOC.POINTER_MOVE": {
          actions: ["setPointerValue"]
        }
      }
    }
  },
  implementations: {
    effects: {
      trackPointerMove({ scope, send }) {
        return domQuery.trackPointerMove(scope.getDoc(), {
          onPointerMove(info) {
            send({ type: "DOC.POINTER_MOVE", point: info.point });
          },
          onPointerUp() {
            send({ type: "DOC.POINTER_UP" });
          }
        });
      }
    },
    actions: {
      syncInputElement({ scope, context }) {
        const inputEl = getHiddenInputEl(scope);
        domQuery.setElementValue(inputEl, context.get("value").toString());
      },
      invokeOnChangeEnd({ context, prop, computed }) {
        prop("onValueChangeEnd")?.({
          value: context.get("value"),
          valueAsDegree: computed("valueAsDegree")
        });
      },
      setPointerValue({ scope, event, context, prop }) {
        const controlEl = getControlEl(scope);
        if (!controlEl) return;
        const deg = getAngle(controlEl, event.point);
        context.set("value", constrainAngle(deg, prop("step")));
      },
      setValueToMin({ context }) {
        context.set("value", MIN_VALUE);
      },
      setValueToMax({ context }) {
        context.set("value", MAX_VALUE);
      },
      setValue({ context, event }) {
        context.set("value", clampAngle(event.value));
      },
      decrementValue({ context, event, prop }) {
        const value = utils.snapValueToStep(
          context.get("value") - event.step,
          MIN_VALUE,
          MAX_VALUE,
          event.step ?? prop("step")
        );
        context.set("value", value);
      },
      incrementValue({ context, event, prop }) {
        const value = utils.snapValueToStep(
          context.get("value") + event.step,
          MIN_VALUE,
          MAX_VALUE,
          event.step ?? prop("step")
        );
        context.set("value", value);
      },
      focusThumb({ scope }) {
        domQuery.raf(() => {
          getThumbEl(scope)?.focus({ preventScroll: true });
        });
      }
    }
  }
});
function getAngle(controlEl, point) {
  const rect = rectUtils.createRect(controlEl.getBoundingClientRect());
  return rectUtils.getPointAngle(rect, point);
}
function clampAngle(degree) {
  return Math.min(Math.max(degree, MIN_VALUE), MAX_VALUE);
}
function constrainAngle(degree, step) {
  const clampedDegree = clampAngle(degree);
  const upperStep = Math.ceil(clampedDegree / step);
  const nearestStep = Math.round(clampedDegree / step);
  return upperStep >= clampedDegree / step ? upperStep * step === MAX_VALUE ? MIN_VALUE : upperStep * step : nearestStep * step;
}
var props = types.createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onValueChange",
  "onValueChangeEnd",
  "readOnly",
  "step",
  "value",
  "defaultValue"
]);
var splitProps = utils.createSplitProps(props);

exports.anatomy = anatomy;
exports.connect = connect;
exports.machine = machine;
exports.props = props;
exports.splitProps = splitProps;
